# -*- coding: utf-8 -*-
"""Genetic Algorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CzNSccC77wIWX1XFLdgewmDbZJ8Mqt3r
"""

import random

def initialize_population(length=4):
    initial_population = []
    for i in range(length):
        chromosome = { "stop_loss": round(random.uniform(1, 99),2),#random.uniform(start, end(inclusive)) --> returns a random num
                       "take_profit": round(random.uniform(1, 99),2),
                       "trade_size": round(random.uniform(10, 99),2), }
        initial_population.append(chromosome)

    return initial_population

#invest == trade size
#invest = cur * trade_per
#cond1 --> his > st_lo ---> pro_lo = -(invest * st_lo)
#cond2 --> his > ta_pro---> pro_lo =  (invest * take_pro)
#cond3 -------------------> pro_lo =  invest * (his/100)
#cur = cur + pro_lo

def evaluate_fitness(chromosome, capital, historical_price_list):
    stop_loss = chromosome["stop_loss"] / 100
    take_pro = chromosome["take_profit"] / 100
    trade_percent = chromosome["trade_size"] / 100

    ini_capital, cur_capital = capital, capital

    for price_change in historical_price_list:
        trade_size = round((cur_capital * trade_percent),2)

        if -price_change > (stop_loss * 100):
            profit_loss = -round((trade_size * stop_loss),2)

        elif price_change > (take_pro * 100):
            profit_loss = round((trade_size * take_pro),2)
        else:
            profit_loss = round((trade_size * (price_change / 100)),2)
        cur_capital = cur_capital + profit_loss

    fitness_score = round((cur_capital-ini_capital),2)
    return fitness_score


def select_parents(population, fitness):
  #giving stronger ones a better chance, still allowing weaker ones a small chance
    min_val = min(fitness)
    if min_val <= 0:
      adjusted_profit = []
      for profit in fitness:
        adjusted_profit.append(profit - min_val + 1)
    else:
        adjusted_profit = fitness

    parent = random.choices(population, weights = adjusted_profit, k=2)
    #k ==2 --> randomly picks 2 chrom from the list of pop with custom fitness
    #choice() --> return single random val and choices() --> list of random ele
    return parent


def crossover(parent1, parent2):
    split_point = random.randint(1, len(parent1)-1)#trade_size split point hobe na tay (-1)
    keys = list(parent1.keys())#return the keys in a list

    child1 = parent1.copy()
    child2 = parent2.copy()

    for i in range(split_point):#split point er ag obdi change hobe
        key = keys[i]
        child1[key], child2[key] = child2[key], child1[key]
    return child1, child2


def mutate(chromosome, rate=0.05):#randomly keys select kore mutate kore
    if random.random() < rate:#returns a random floating number between 0 and 1
        dict_key = random.choice(list(chromosome.keys()))
        chromosome[dict_key] = round(random.uniform(1, 99), 2)
    return chromosome


def genetic_algorithm(capital, generation, trading_prices=None, population_size=4):
    population = initialize_population(population_size)
    for i in range(generation):
        fitness_score = []
        for chromosome in population:
          profit = evaluate_fitness(chromosome, capital, trading_prices)
          fitness_score.append(profit)

        population_score = []
        for i in range(len(population)):
            population_score.append((population[i], fitness_score[i]))

        #anking the population from best to worst based on fitness val
        population_score.sort(key=lambda x: x[1], reverse=True)#sort should be called with a keyword argument
        #The sort() function needs labeling things properly using words like key= or reverse=


        new_population = []
        for i in range(2):#chose 2 best best chromosome
            new_population.append(population_score[i][0])


        while len(new_population) < population_size:

            parent1, parent2 = select_parents(population, fitness_score)#sending initial 4 chromosome

            child1, child2 = crossover(parent1, parent2)

            new_population.append(mutate(child1))
            new_population.append(mutate(child2))

        population = new_population[:population_size]#prev best 2 chrom and genrated parent1, parent 2 are stored to compute next iteration

    best_strategy = population[0]
    final_profit = evaluate_fitness(best_strategy, capital, trading_prices)


    for chromosome in population:#checking whether pop{0} is thew bes
        profit = evaluate_fitness(chromosome, capital, trading_prices)
        if profit > final_profit:
            best_strategy = chromosome
            final_profit = profit

    return best_strategy, final_profit

capital = 1000
historical_price_list = [-1.2, 3.4, -0.8, 2.1, -2.5, 1.7, -0.3, 5.8, -1.1, 3.5]#price change
generation = 10#iteration
best_strategy, final_profit = genetic_algorithm(capital, generation, trading_prices = historical_price_list)
print("Output of part-1:")
print("Best Strategy:", best_strategy)
print("Final Profit:", final_profit)




def two_point_crossover(parent1, parent2):

    key = list(parent1.keys())
    pos = random.sample(range(len(key)), 2)
    crossover1, crossover2 = sorted(pos)
    child1, child2 = parent1.copy(), parent2.copy()

    for i in range(crossover1, crossover2+1):
        child1[key[i]], child2[key[i]] = child2[key[i]], child1[key[i]]
    return child1, child2

parent1, parent2 = initialize_population(2)
child1, child2 = two_point_crossover(parent1, parent2)
print("Output of part-2:")
print("Chosen Parent 1:", parent1)
print("Chosen Parent 2:", parent2)
print("Chosen child 1:", child1)
print("Chosen Child 2:", child2)

#lambda is quick way to creat a func without giving it a name
#key lambda x ---> here x is the created function which stores touple(pop[i], fit[i])
#x:x[1] --> here, x[1] --> indicates to sort based on fitness score
#basically we impose to sort itself based on a specific criteria
#reverse=True ---> indicates to sort from biggest to smallest.