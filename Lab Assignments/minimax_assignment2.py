# -*- coding: utf-8 -*-
"""Minimax_assignment2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16iZlMQ3du78f2Q55HPazoXNJRyL4fASX

Task-1
"""

import math
import random


def strength_function(strength_val):
    return math.log2(strength_val + 1) + (strength_val / 10)

def utility_function(max_val, min_val):
    noise_val = ((-1) ** (random.randint(0, 1))) * ((random.randint(1, 10)) / 10)
    max_res, min_res = strength_function(max_val), strength_function(min_val)
    utility = max_res - min_res + noise_val
    return round(utility, 2)

def minimax(depth, alpha, beta, max_base, min_base, max_player_turn):
    if depth == 5:
        return utility_function(max_base, min_base)

    branch = 2
    max_val, min_val = float('-inf'), float('inf')
    if max_player_turn == True:
        for i in range(branch):
            val = minimax(depth + 1, alpha, beta, max_base, min_base, False)
            max_val, alpha = max(max_val, val), max(alpha, val)
            if beta <= alpha:
                break
        return max_val
    else:
        for i in range(branch):
            val = minimax(depth + 1, alpha, beta, max_base, min_base, True)
            min_val, beta = min(min_val, val), min(beta, val)
            if beta <= alpha:
                break
        return min_val

def play_chess(game_num, starting_player, carl_base, caru_base):
    if game_num % 2 == 1:#round=1,3
      if starting_player == 0:
        max_name, min_name = "Magnus Carlsen", "Fabiano Caruana"
        max_base, min_base = carl_base, caru_base
      else:#ind=1
         max_name, min_name = "Fabiano Caruana", "Magnus Carlsen"
         max_base, min_base = caru_base, carl_base
    else:#round = 2,4
        if starting_player == 0:
          max_name, min_name = "Fabiano Caruana", "Magnus Carlsen"
          max_base, min_base = caru_base, carl_base
        else:#ind=1
          max_name, min_name = "Magnus Carlsen", "Fabiano Caruana"
          max_base, min_base = carl_base, caru_base


    max_val,  min_val = strength_function(max_base), strength_function(min_base)
    final_utility = minimax(0, float('-inf'), float('inf'), max_val, min_val, True)

    if final_utility > 0:
        master = f"{max_name} (Max)"
    elif final_utility < 0:
        master = f"{min_name} (Min)"
    else:
        master = "Draw"

    return final_utility, master


start_player = int(input("Enter starting player for game 1 (0 for Carlsen, 1 for Caruana): "))
carlsen_strength = float(input("Enter base strength for Carlsen: "))
caruana_strength = float(input("Enter base strength for Caruana: "))

carl_num_win, caru_num_win, draw = 0, 0 ,0

for nth_game in range(4):

   best_val, chess_master = play_chess(nth_game+1, start_player, carlsen_strength, caruana_strength)
   print(f"Game {nth_game+1} Winner: {chess_master} (Utility value: {best_val})")

   if "Carlsen" in chess_master:
     carl_num_win += 1
   elif "Caruana" in chess_master:
     caru_num_win+=1
   else:
     draw += 1

print("\nOverall Results:")
print(f"Magnus Carlsen Wins: {carl_num_win}\nFabiano Caruana Wins: {caru_num_win}\nDraws: {draw}")

if carl_num_win > caru_num_win:
  print("Overall Winner: Magnus Carlsen")
elif caru_num_win > carl_num_win:
  print("Overall Winner: Fabiano Caruana")
else:
  print("Overall Winner: Draw")

"""Task-2"""

import math
import random


def strength_function(strength_val):
    return math.log2(strength_val + 1) + (strength_val / 10)

def utility_function(max_val, min_val):
    noise_val = ((-1) ** (random.randint(0, 1))) * ((random.randint(1, 10)) / 10)
    max_res, min_res = strength_function(max_val), strength_function(min_val)
    utility = max_res - min_res + noise_val
    return round(utility, 2)

def normal_minimax(depth, alpha, beta, max_base, min_base, max_player_turn):
    if depth == 5:
        return utility_function(max_base, min_base)

    branch = 2
    if max_player_turn == True:
        max_val = float('-inf')
        for i in range(branch):
            val = normal_minimax(depth + 1, alpha, beta, max_base, min_base, False)
            max_val, alpha = max(max_val, val), max(alpha, val)
            if beta <= alpha:
                break
        return max_val
    else:
        min_val = float('inf')
        for i in range(branch):
            val = normal_minimax(depth + 1, alpha, beta, max_base, min_base, True)
            min_val, beta = min(min_val, val), min(beta, val)
            if beta <= alpha:
                break
        return min_val


def controlled_minimax(depth, alpha, beta, max_base, min_base, max_player_turn):
    if depth == 5:
        return utility_function(max_base, min_base)

    branch = 2
    if max_player_turn == True:
        max_val = float('-inf')
        for i in range(branch):
            val = controlled_minimax(depth + 1, alpha, beta, max_base, min_base, False)
            max_val, alpha = max(max_val, val), max(alpha, val)
            if beta <= alpha:
                break
        return max_val
    else:
        forced_val = float('-inf')
        for i in range(branch):
            val = controlled_minimax(depth + 1, alpha, beta, max_base, min_base, True)
            forced_val, alpha = max(forced_val, val) , max(alpha, val)#only change compared to normal_minmax
            #the MAX is controlling the MIN's moves, MIN is no longer choosing the worst for MAX
            if beta <= alpha:
                break
        return forced_val



def play_chess(start_ind, cost, light_base, l_base):
    if start_ind == 0:
        max_player, min_player = "Light", "L"
        max_base, min_base = light_base, l_base
    else:
        max_player, min_player = "L", "Light"
        max_base, min_base = l_base, light_base


    normal = normal_minimax(0, float('-inf'), float('inf'), max_base, min_base, True)
    mind_control = controlled_minimax(0, float('-inf'), float('inf'), max_base, min_base, True)

    incurring_cost = round((mind_control - cost), 2)

    print(f"\nMinimax value without Mind Control: {round(normal, 2)}\nMinimax value with Mind Control: {round(mind_control, 2)}")
    print(f"Minimax value with Mind Control after incurring the cost: {incurring_cost}")

    if light_base > l_base:
         if incurring_cost > normal:
             print(f"\n{max_player} should NOT use Mind Control as the position is already winning.")
         else:
             print(f"\n{max_player}  should NOT use Mind Control as it backfires.")
    else:
         if incurring_cost > normal:
             print(f"\n{max_player} should use Mind Control.")
         else:
             print(f"\n{max_player}  should NOT use Mind Control as the position is losing either way.")


start_ind = int(input("Enter who goes first (0 for Light, 1 for L): "))
cost = float(input("Enter the cost of using Mind Control: "))
light_base = float(input("Enter base strength for Light: "))
l_base = float(input("Enter base strength for L: "))

play_chess(start_ind, cost, light_base, l_base)